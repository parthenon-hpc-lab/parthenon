

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sparse implementation &mdash; Parthenon  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="State Management" href="state.html" />
    <link rel="prev" title="Prolongation and Restriction Operations" href="refinement_operations.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Parthenon
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../README.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../amr.html">Adaptive Mesh Refinement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../boundary_communication.html">Boundary communication-in-one concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../boundary_communication.html#sparse-boundary-communication">Sparse boundary communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../boundary_conditions.html">Boundary Conditions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../building.html">Building Parthenon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../concepts_lite.html">C++11 Style Concepts Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../constants.html">Parthenon Built-in Physical Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coordinates.html">Coordinates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development.html">Parthenon developer guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver.html">Application Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../inputs.html">Input Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../instrumentation.html">Performance Instrumentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../integrators.html">Integrators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../load_balancing.html">Load Balancing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nested_par_for.html">Nested Parallelism</a></li>
<li class="toctree-l1"><a class="reference internal" href="../outputs.html">Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parthenon_arrays.html">Parthenon Set-Dimensional Arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parthenon_arrays.html#parthenon-arbitrary-dimensional-arrays">Parthenon Arbitrary-Dimensional Arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="../parthenon_manager.html">Parthenon Manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../particles.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reductions.html">Task-based reductions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../solvers.html">Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sphinx-doc.html">How to Use Sphinx for Writing Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tasks.html">Tasks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tests.html">How to add tests to Parthenon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../weak_scaling.html">Running a Weak Scaling Test in Parthenon</a></li>
<li class="toctree-l1"><a class="reference internal" href="boundary.html">Boundary related classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="containers.html">Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="refinement_operations.html">Prolongation and Restriction Operations</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Sparse implementation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#sparse-fields">Sparse Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="#turning-off-sparse">Turning off sparse</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#run-time">Run-time</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compile-time">Compile-time</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sparse-naming">Sparse naming</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sparse-allocation-and-deallocation-implementation">Sparse allocation and deallocation implementation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#allocation-status">Allocation status</a></li>
<li class="toctree-l3"><a class="reference internal" href="#deallocation">Deallocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boundary-exchange">Boundary exchange</a></li>
<li class="toctree-l3"><a class="reference internal" href="#amr-and-load-balancing">AMR and load balancing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-footprint-reporting">Memory Footprint Reporting</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="state.html">State Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mesh/domain.html">Domain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mesh/mesh.html">Mesh</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Parthenon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Sparse implementation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/src/interface/sparse.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="sparse-implementation">
<span id="sparse-impl"></span><h1>Sparse implementation<a class="headerlink" href="#sparse-implementation" title="Link to this heading"></a></h1>
<p>This file describes the implementation of sparse variables in Parthenon.
Parthenon also provides the capability to use <strong>sparse</strong> fields, where
“sparse” really refers to two distinct and orthogonal concepts, namely
(a) a family or pool of distinct and separate variable fields that share
a common base name and are distinguished by a sparse ID (<strong>sparse
naming</strong>), and (b) variables that are only allocated on some but not
necessarily all mesh blocks in the domain (<strong>sparse fields</strong>). In
principle, both of these “sparse” concepts can be used independently,
i.e.  we could make a family of dense variables that share a base name
and are distinguished by sparse IDs, or we could simply have a single
variable with a label without a sparse ID that is only allocated on some
blocks but not others. However, in practice these two concepts are often
used together. As a result, the current implementation of sparse fields
in parthenon only allows fields to be sparse if they are sparsely named.
This should be relaxed in the future. These two concepts are addressed
in separate sections below.</p>
<section id="sparse-fields">
<h2>Sparse Fields<a class="headerlink" href="#sparse-fields" title="Link to this heading"></a></h2>
<p>For computation and memory savings, it may be desirable to explicitly
evolve certain fields only on certain sub-regions of the grid. In
regions of the grid where certain fields are not evolved, they are
assumed to take some default value (usually zero) and storage for these
fields does not need to be allocated in those sub-regions. Fields that
are explicitly evolved on only certain sub-regions of the grid are
termed “sparse fields.”</p>
<p>Some examples of where sparse fields might be desirable:</p>
<ul class="simple">
<li><p>Properties (density, temperature, etc.) of materials that are only present in
certain parts of the simulation. One does not want to allocate memory
that contains all zeros and perform operations on zeros in regions where
the material is not present.</p></li>
<li><p>A self-gravitating fluid in a vacuum.
Often, astrophysics codes will model this by including fluid throughout
the entire simulation domain but set a floor on the density and
temperature of the material to create an effective “atmosphere” around
the actual self-gravitating system. Regions that are set to the floor do
not necessarily need to be explicitly tracked and the fluid quantities
could be treated as sparse fields.</p></li>
<li><p>Material that is transitioning
between non-equilibrium nuclear burning and nuclear statistical
equilibrium (NSE). In the non-equilibrium regions, the abundances of all
nuclear species are required to define the composition of the material
while in the regions that are in NSE only one field (the electron
fraction) is required to define the composition.</p></li>
</ul>
<p>In Parthenon, sparse fields are implemented at the block level, meaning
that a field is allocated everywhere or nowhere on each block in the
simulation. The set of possible operations for a sparse field are:</p>
<ul class="simple">
<li><p><em>Allocation on initialization:</em> Sparse variables need to be allocated
by hand in the <code class="docutils literal notranslate"><span class="pre">ProblemGenerator</span></code> in regions where they are
non-zero.</p></li>
<li><p><em>Allocation due to local changes:</em> For some types of sparse fields
(e.g. nuclear abundances fields for material transitioning in and out
of NSE), it may be desirable to allocate them based on the local
state on the block (e.g. allocate abundances if the temperature is
anywhere on the block below some threshold). This is an operation
that needs to be defined in a task by the downstream code, since it
is problem specific. <strong>Currently, Parthenon does not have this
capability. It will probably be necessary to define some hooks for
checking blocks for the necessity of allocation and having some
internal Parthenon functions for actually performing the
allocation.</strong></p></li>
<li><p><em>Allocation due to neighbors:</em> If a sparse field on a neighbor block
passes ghost data that is anywhere above the
<code class="docutils literal notranslate"><span class="pre">allocation_threshold</span></code>, the receiving block will allocate the
sparse field if it is unallocated before loading the ghost data.
<code class="docutils literal notranslate"><span class="pre">allocation_threshold</span></code> is set in the <code class="docutils literal notranslate"><span class="pre">Metadata</span></code> of a field. A
detailed description of sparse ghost zone communication is given
<a class="reference internal" href="../boundary_communication.html#sparse-boundary-comm"><span class="std std-ref">here</span></a>.</p></li>
<li><p><em>Allocation due to other fields:</em> In some instances, we may want to
allocate or deallocate a sparse field when another sparse field is
allocated or deallocated, not when the field itself changes state
(i.e. we would like to allocate a sparse field describing a dependent
variable whenever a corresponding inedendent sparse variable is
allocated). For this, we introduce the notion of <em>controlling</em> and
<em>controlled</em> fields. A controlling field has a list of field names
associated with it and whenever allocation or deallocation of the
controlling field occurs on a block, it also goes through the list of
controlled fields associated with it and allocates or deallocates
them. To make a controlled sparse field, a sparse pool can be created
using <code class="docutils literal notranslate"><span class="pre">SparsePool(base_name,</span> <span class="pre">metadata,</span> <span class="pre">controller_base_name,</span> <span class="pre">...)</span></code>
where <code class="docutils literal notranslate"><span class="pre">controller_base_name</span></code> is base name of the controlling field.
Fields associated with this sparse pool will only be allocated or
deallocated based on the corresponding fields in the
<code class="docutils literal notranslate"><span class="pre">controller_base_name</span></code> sparse pool. <strong>There are no checks performed
that the two pools contain the same set of sparse indices.</strong></p></li>
<li><p><em>Initialization after allocation:</em> Depending on what a particular
sparse field is modeling, its values on a block may need to be
initialized to values that are non-zero and/or depend on the state of
other fields on the block. Since this requirement is problem
dependent, downstream codes using Parthenon must define tasks that
perform this initialization. If no task is defined, a newly
initialized field is everywhere on the block set to the
<code class="docutils literal notranslate"><span class="pre">default_value</span></code> defined in its <code class="docutils literal notranslate"><span class="pre">Metadata</span></code>. <strong>The implementation
of this needs to be fleshed out and more extensively tested and this
description needs more detail about how to register initialization
functions. Also needs to describe how to check for sub-regions of a
block where uninitialized data has been passed in. In the downstream
use cases so far, this has not been a necessary feature.</strong></p></li>
<li><p><em>Deallocation due to local changes:</em> Currently, the only way for a
sparse field to be deallocated is if its absolute value falls below
<code class="docutils literal notranslate"><span class="pre">deallocation_threshold</span></code> everywhere on the interior of a block (or
if its controlling field is deallocated). The
<code class="docutils literal notranslate"><span class="pre">deallocation_threshold</span></code> is set in the sparse fields metadata.</p></li>
<li><p><em>Deallocation due to other fields:</em> If a field is controlled, it is
deallocated whenever its controlling field is deallocated.</p></li>
<li><p><em>Access if allocated:</em> Since fields are mainly accessed through packs
in Parthenon based codes (a <code class="docutils literal notranslate"><span class="pre">VariablePack</span></code>, <code class="docutils literal notranslate"><span class="pre">MeshBlockPack</span></code>, or
<code class="docutils literal notranslate"><span class="pre">SparsePack&lt;...&gt;</span></code>), packs need to carry around information about
the allocation status of the requested fields in the pack. A “dense
sparse packing” strategy is used in <code class="docutils literal notranslate"><span class="pre">SparsePack&lt;...&gt;</span></code>, where only
allocated fields are included in the index space of the pack. Here,
the index space means <code class="docutils literal notranslate"><span class="pre">(block,</span> <span class="pre">field,</span> <span class="pre">k,</span> <span class="pre">j,</span> <span class="pre">i)</span></code> and for sparse
fields the number of allocated fields can change from block to block
which means the index space is logically ragged for dense sparse
packing. For each block, the range of indices corresponding to a
particular field in the pack can be accessed on device and iterated
over (if the range has positive size, a negative size for the range
indicates that none of the corresponding fields are allocated).
Looping over fields in these type of packs generally requires
hierarchichal parallelism. Currently, <code class="docutils literal notranslate"><span class="pre">VariablePack</span></code> and
<code class="docutils literal notranslate"><span class="pre">MeshBlockPack</span></code> employ a “sparse sparse packing” strategy, where
all fields are included in the index space of the pack but the
allocation status of <code class="docutils literal notranslate"><span class="pre">(block,</span> <span class="pre">field)</span></code> must be checked before
accessing <code class="docutils literal notranslate"><span class="pre">(block,</span> <span class="pre">field,</span> <span class="pre">k,</span> <span class="pre">j,</span> <span class="pre">i)</span></code> since this is not guaranteed to
point to valid memory. *There is “dense sparse pack” implementation
of <code class="docutils literal notranslate"><span class="pre">VariablePack</span></code> and <code class="docutils literal notranslate"><span class="pre">MeshBlockPack</span></code> in the branch
<code class="docutils literal notranslate"><span class="pre">lroberts36/merge-sparse-with-jdolence-sparse</span></code> that is being used
in <code class="docutils literal notranslate"><span class="pre">Riot</span></code>. This should probably be brought into <code class="docutils literal notranslate"><span class="pre">develop</span></code>, since
the “sparse sparse pack” access pattern is probably not desirable.</p></li>
<li><p><em>Flatten outer indices:</em> Most common packs over <code class="docutils literal notranslate"><span class="pre">MeshData</span></code> produce
a 5-dimensional data structure, where the slowest two moving indices
are over <code class="docutils literal notranslate"><span class="pre">MeshBlock</span></code>s then tensor/vector components of
<code class="docutils literal notranslate"><span class="pre">Variable</span></code>s. However, it is sometimes desirable to construct a
4-dimensional data structure where the slowest moving index ranges
over all variables and all blocks. So for example if we had a system
with 9 blocks and 5 variables per block, the slowest moving index
would be of size 45. This can be enabled <code class="docutils literal notranslate"><span class="pre">SparsePack``s</span> <span class="pre">with</span> <span class="pre">the</span>
<span class="pre">``GetFlat</span></code> series of factory functions or by passing the optional
<code class="docutils literal notranslate"><span class="pre">flat</span></code> boolean into the constructor.</p></li>
</ul>
<p>In comparison to a sparse field, a dense field only requires the
operation <em>Access</em>.</p>
<p><strong>To set the thresholds for a sparse field, after creating the
``Metadata`` object that will be used for the field, call
``Metadata::SetSparseThresholds(allocation_threshold, deallocation_threshold,  default_value)``.</strong></p>
</section>
<section id="turning-off-sparse">
<h2>Turning off sparse<a class="headerlink" href="#turning-off-sparse" title="Link to this heading"></a></h2>
<p>The sparse allocation feature can be turned off at run- or compile-time.
The sparse naming feature cannot be turned off.</p>
<section id="run-time">
<span id="sparse-run-time"></span><h3>Run-time<a class="headerlink" href="#run-time" title="Link to this heading"></a></h3>
<p>Setting <code class="docutils literal notranslate"><span class="pre">enable_sparse</span></code> to <code class="docutils literal notranslate"><span class="pre">false</span></code> (default is <code class="docutils literal notranslate"><span class="pre">true</span></code>) in the
<code class="docutils literal notranslate"><span class="pre">parthenon/sparse</span></code> block of the input file turns on the “fake sparse”
mode. In this mode, all variables are always allocated on all blocks,
just if they were all dense, and they will not be automatically
deallocated. Thus the fake sparse mode produces the same results as if
all variables were declared dense, but the infrastructure will still
perform <code class="docutils literal notranslate"><span class="pre">IsAllocated</span></code> checks, so this mode does not remove the sparse
infrastructure overhead, but it is useful to debug issues arising with
the usage of sparse variables.</p>
</section>
<section id="compile-time">
<span id="sparse-compile-time"></span><h3>Compile-time<a class="headerlink" href="#compile-time" title="Link to this heading"></a></h3>
<p>Turning on the CMake option <code class="docutils literal notranslate"><span class="pre">PARTHENON_DISABLE_SPARSE</span></code> turns on fake
sparse mode (see above) and also replaces all the <code class="docutils literal notranslate"><span class="pre">IsAllocated</span></code>
functions with essentially
<code class="docutils literal notranslate"><span class="pre">constexpr</span> <span class="pre">bool</span> <span class="pre">IsAllocated()</span> <span class="pre">const</span> <span class="pre">{</span> <span class="pre">return</span> <span class="pre">true;</span> <span class="pre">}</span></code> so that they
should all be optimized out and thus the sparse infrastructure overhead
should be removed, which will be useful for measuring the performance
impact of the sparse overhead. Note however, that there will still be
some overhead due to the sparse implementation on the host. For example,
the allocation status of the variables will still be part of variable
pack caches and will be checked when retrieving packs from the cache.
However, since fake sparse is enabled, the allocation statuses will
always be all true, thus not resulting in any additional cache misses.</p>
<p>If sparse is compile-time disabled, this information is passed through
to the regression test suite, which will adjust its comparison to gold
results accordingly.</p>
</section>
</section>
<section id="sparse-naming">
<h2>Sparse naming<a class="headerlink" href="#sparse-naming" title="Link to this heading"></a></h2>
<p>Of the two sparse concepts described above, sparse naming is much
simpler to implement, because it is essentially just a convenient front
end to the machinery provided by the state descriptor, containers, and
other parts of the Parthenon infrastructure, all of which don’t need to
know anything about sparse naming. Once a family or pool of variables
sharing the same base name but having different sparse IDs is added to
the state descriptor, they are treated exactly like ordinary, unrelated
variables that all have distinct labels. The only exception is functions
that take a set of flags or labels to pull out a list of variables.
These functions are aware that multiple variables can share the same
base name, and it will match all those variables if the base name is
given in a list of labels, furthermore, many of such functions take an
optional list of sparse IDs, which can be used to restrict the variable
selection to specific sparse IDs. But again, these are just front end
conveniences. Once the list of variables is assembled, all the variables
are treated as completely independently and unrelated, just like dense
variables.</p>
<p>Sparse naming is implemented through the <code class="docutils literal notranslate"><span class="pre">SparsePool</span></code> class, which can
be added to a state descriptor via <code class="docutils literal notranslate"><span class="pre">AddSparsePool</span></code>. A <code class="docutils literal notranslate"><span class="pre">SparsePool</span></code>
consists of: (i) a base name, (ii) a shared <code class="docutils literal notranslate"><span class="pre">Metadata</span></code> instance, and
(iii) a list of sparse IDs, which may be used. Note that the list of
sparse IDs must be specified when the sparse pool is created and once
its added to the state descriptor, that list cannot be changed. This
limitation drastically simplifies the sparse naming implementation,
because it means that we know the complete list of variables at the
beginning and that list is always the same on all mesh blocks. The
individual <code class="docutils literal notranslate"><span class="pre">Variable</span></code> instances that are created for each sparse
ID have a label of the form <code class="docutils literal notranslate"><span class="pre">&lt;base</span> <span class="pre">name&gt;_&lt;sparse</span> <span class="pre">index&gt;</span></code> and the have
the same metadata as the shared metadata of the pool, with two
exceptions: (i) the shape of the variable can be set per sparse ID
(i.e. some ID could be a scalar, another a vector of length 2, another a
vector of length 12, another a rank-3 tensor, etc.), and (ii) related to
the shape, the <code class="docutils literal notranslate"><span class="pre">Metadata::Vector</span></code> and <code class="docutils literal notranslate"><span class="pre">Metadata::Tensor</span></code> flags can
be individually set per sparse ID as well.</p>
<p>The sparse ID can be any integer (positive, negative, and zero) except
the smallest possible integer (<code class="docutils literal notranslate"><span class="pre">std::numeric_limits&lt;int&gt;::min()</span></code>),
which is reserved to mean an invalid sparse ID. It is not allowed to add
a dense variable with a label that is used as a base name for a
<code class="docutils literal notranslate"><span class="pre">SparsePool</span></code> or vice versa.</p>
<p>When a sparse pool is added to the state descriptor, it simply adds a
separate variable for each of its sparse IDs with the appropriate
metadata and composite label (as described above). After this point, the
rest of the infrastructure treats those variables like any other
unrelated variables, with the following exception.When one specifies a
variable label in a list of labels, for example in the <code class="docutils literal notranslate"><span class="pre">PackVariable</span></code>
or <code class="docutils literal notranslate"><span class="pre">PackVariablesAndFluxes</span></code> functions, one can simply specify the base
name in the list of labels, which will add all sparse variables with
that base name to the resulting list of variables. Furthermore, the
<code class="docutils literal notranslate"><span class="pre">Pack*</span></code> functions also take an optional argument to specify a list of
sparse IDs. If such a list is present, then only sparse variables with
an ID from that list will be added to the pack. However, when using a
label to refer to a single variable, one must specify the full label
(base name plus sparse ID) to refer to a particular sparse variable.</p>
</section>
<section id="sparse-allocation-and-deallocation-implementation">
<h2>Sparse allocation and deallocation implementation<a class="headerlink" href="#sparse-allocation-and-deallocation-implementation" title="Link to this heading"></a></h2>
<p><em>This section has not been completely updated from the original sparse
implementation and is kept here as a reference for developers.</em></p>
<p>Implementing the sparse allocation capability requires deep changes in
the entire infrastructure, because the entire infrastructure assumed
that all variables are always allocated on all blocks. It also raises
the question of how to handle the case when one block has a sparse
variable allocated and its neighbor doesn’t. Under what circumstances
will the neighboring block have to allocate that sparse variable and how
will this be communicated? Furthermore, the use of MPI to communicate
boundary and other data between blocks on different MPI ranks requires
that the sending and receiving ranks both call send and receive
functions for each message passed between them, which complicates the
situation where two neighboring blocks don’t have the same sparse
variables allocated and thus would like to communicate data for
different sets of variables.</p>
<p>Before describing the bigger infrastructure changes to handle the
boundary communication for sparse variables, here are some smaller
changes that are necessary for sparse variables to work.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Variable</span></code> tracks its allocation status and has member
functions to allocate and deallocate its data (<code class="docutils literal notranslate"><span class="pre">data</span></code>, <code class="docutils literal notranslate"><span class="pre">flux</span></code>,
and <code class="docutils literal notranslate"><span class="pre">coarse_s</span></code>).</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">Variable</span></code> now knows its dimensions and coarse dimensions.
Because the <code class="docutils literal notranslate"><span class="pre">ParArrayND&lt;T&gt;</span> <span class="pre">data</span></code> member holding the actual variable
data is not necessarily allocated (i.e., it has a size of 0), we can
no longer use its size to get the dimension of the <code class="docutils literal notranslate"><span class="pre">Variable</span></code>,
but we still need to know its dimensions when it’s unallocated, for
example when adding it to a pack. Similarly, the <code class="docutils literal notranslate"><span class="pre">coarse_s</span></code> member
used to be queried to get the coarse dimensions, but that is also not
always allocated, thus <code class="docutils literal notranslate"><span class="pre">Variable</span></code> also directly knows its
coarse dimensions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Variable</span></code>, <code class="docutils literal notranslate"><span class="pre">MeshBlock</span></code>, <code class="docutils literal notranslate"><span class="pre">MeshBlockData</span></code>, variable packs,
and mesh block packs, all have new member functions <code class="docutils literal notranslate"><span class="pre">IsAllocated</span></code>
to query whether a particular variable is allocated or not. Generally
speaking, whenever the data or fluxes of a variable are accessed,
such accesses need to be guarded with <code class="docutils literal notranslate"><span class="pre">IsAllocated</span></code> checks.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">pvars_cc_</span></code> field of the <code class="docutils literal notranslate"><span class="pre">MeshRefinement</span></code> class is now a
<code class="docutils literal notranslate"><span class="pre">std::vector&lt;std::shared_ptr&lt;Variable&lt;Real&gt;&gt;&gt;</span></code> instead of a
<code class="docutils literal notranslate"><span class="pre">std::vector&lt;std::tuple&lt;ParArrayND&lt;Real&gt;,</span> <span class="pre">ParArrayND&lt;Real&gt;&gt;&gt;</span></code>. The
problem with storing (shallow) copies of the <code class="docutils literal notranslate"><span class="pre">ParArrayND</span></code>s
<code class="docutils literal notranslate"><span class="pre">data</span></code> and <code class="docutils literal notranslate"><span class="pre">coarse_s</span></code> is that they don’t point to the newly
allocated views if a variable is initially unallocated and then gets
allocated during the evolution. Storing a pointer to the
<code class="docutils literal notranslate"><span class="pre">Variable</span></code> instance works because that one remains the same
when it gets allocated.</p></li>
<li><p>The caching mechanisms for variable packs, mesh block packs, send
buffers, receive (i.e., set) buffers, and restrict buffers now all
include the allocation status of all the contained variables (as a
<code class="docutils literal notranslate"><span class="pre">std::vector&lt;int&gt;</span></code> because it’s only used on the host). When a pack
or buffers collection is requested, the allocation status of the
cached entity is compared to the current allocation status of the
variables and if they don’t match, the pack or buffer collection is
recreated.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Globals</span></code> namespace contains some global sparse settings
(whether sparse is enabled, allocation/deallocation thresholds, and
deallocation count).</p></li>
</ul>
<p>Below follows a detailed description of the main sparse allocation
implementation.</p>
<section id="allocation-status">
<h3>Allocation status<a class="headerlink" href="#allocation-status" title="Link to this heading"></a></h3>
<p>Every <code class="docutils literal notranslate"><span class="pre">Variable</span></code> is either allocated or deallocated at all times.
Furthermore, the <code class="docutils literal notranslate"><span class="pre">Variable</span></code>s with the same label but
corresponding to different stages (i.e., <code class="docutils literal notranslate"><span class="pre">MeshBlockData</span></code> instances) of
the same <code class="docutils literal notranslate"><span class="pre">MeshBlock</span></code> are always either allocated or deallocated on all
stages of the mesh block. This is enforced by the fact that the only
public methods to (de)allocate a variable is through the mesh block. The
<code class="docutils literal notranslate"><span class="pre">MeshBlock::AllocateSparse</span></code> and <code class="docutils literal notranslate"><span class="pre">MeshBlock::AllocSparseID</span></code> functions
are meant to be used in the user code to specifically allocate a sparse
variable on a given block (usually, this would be done in the problem
generator). They are also used internally by the infrastructure to
allocate a sparse variable on a block if it receives non-zero boundary
data for that block, see <a class="reference internal" href="#boundary-exchange">Boundary exchange</a> for
details. The infrastructure can also automatically deallocate sparse
variables on a block, see <a class="reference internal" href="#deallocation">Deallocation</a>.</p>
<p>When a <code class="docutils literal notranslate"><span class="pre">Variable</span></code> is allocated, its <code class="docutils literal notranslate"><span class="pre">data</span></code>, <code class="docutils literal notranslate"><span class="pre">flux</span></code>, and
<code class="docutils literal notranslate"><span class="pre">coarse_s</span></code> fields are allocated. When the variable is deallocated,
those fields are reset to <code class="docutils literal notranslate"><span class="pre">ParArrayND</span></code>s of size 0.</p>
</section>
<section id="deallocation">
<h3>Deallocation<a class="headerlink" href="#deallocation" title="Link to this heading"></a></h3>
<p>There is a new task called <code class="docutils literal notranslate"><span class="pre">SparseDealloc</span></code> in
<code class="docutils literal notranslate"><span class="pre">src/interface/update.cpp</span></code> taking a <code class="docutils literal notranslate"><span class="pre">MeshData</span></code> pointer. It is meant
to be run after the update task for the last stage (of course, it does
not have to be run every time step). On every block, it checks the
values of all sparse variables. If the maximum absolute value is below
the user-defined deallocation threshold, the variable is flagged for
deallocation on that block. The variable is only actually deallocated if
it has been flagged for deallocation a certain number of times in a row
(if any of the values exceeds the deallocation threshold, the counter is
reset to 0). That number is the deallocation count, which is also
settable by the user in the input file.</p>
</section>
<section id="boundary-exchange">
<h3>Boundary exchange<a class="headerlink" href="#boundary-exchange" title="Link to this heading"></a></h3>
<p>Boundary communication can trigger allocation of a field on the
receiving block if the communicated ghost data is above the allocation
threshold. Otherwise sparse boundary communication is the same as dense
boundary communication. A detailed description of the boundary
communication and flux correction implementation in Parthenon is given
<a class="reference internal" href="../boundary_communication.html#sparse-boundary-comm"><span class="std std-ref">here</span></a>.</p>
</section>
<section id="amr-and-load-balancing">
<h3>AMR and load balancing<a class="headerlink" href="#amr-and-load-balancing" title="Link to this heading"></a></h3>
<p>The sparse implementation for AMR and load balancing is quite straight
forward. For AMR, when we create new mesh blocks, we allocate the same
variables on them as there were allocated on the old mesh blocks the new
ones are created from.</p>
<p>For the load balancing, we need to send the allocation statuses of the
variables together with their data. So we add flags at the beginning of
the send/receive buffers to indicate the allocation statuses. There is
one flag per variable. The rest of the buffer is unchanged and always
includes space for all variables regardless whether they are allocated
or not. This simplifies the implementation drastically, because all the
MPI messages have the same size and the sender and receiver know what
that size is without needing the know the allocation status of the other
block. The remaining changes are as follows:</p>
<ul class="simple">
<li><p>In <code class="docutils literal notranslate"><span class="pre">Mesh::PrepareSendSameLevel</span></code> we only fill the send buffer (using
<code class="docutils literal notranslate"><span class="pre">BufferUtility::PackData</span></code>) if the variable is allocated, otherwise
we simply skip that region of the buffer (and leave its values
uninitialized, since they won’t be read) so that the data for each
variable is in the same place as if all variables were allocated.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">Mesh::PrepareSendCoarseToFineAMR</span></code> and
<code class="docutils literal notranslate"><span class="pre">Mesh::PrepareSendFineToCoarseAMR</span></code> we do the same as above, but
instead of leaving regions of the buffer belonging to unallocated
variables uninitialized, we fill them with zeros (using
<code class="docutils literal notranslate"><span class="pre">BufferUtility::PackZero</span></code>) since the target block may have the
variable allocated even if the sender doesn’t (actually, I think this
can only happen for fine-to-coarse and not for coarse-to-fine).</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">Mesh::FillSameRankFineToCoarseAMR</span></code> when filling in the
destination data, we write zeros if the fine source block doesn’t
have the variable allocated. Whereas in
<code class="docutils literal notranslate"><span class="pre">Mesh::FillSameRankCoarseToFineAMR</span></code> we make sure the source and
destination blocks have the same allocation status for each variable
and we simply skip unallocated variables.</p></li>
<li><p>In all three types of <code class="docutils literal notranslate"><span class="pre">Mesh::FinishRecv*</span></code> functions, we read the
allocation flags for all variables from the buffer, and we allocate
it on the receiving block if the sending block had it allocated but
it’s not yet allocated on the receiving block. We then proceed to
read the buffer only if the variable is allocated on the receiving
block.</p></li>
</ul>
</section>
<section id="memory-footprint-reporting">
<h3>Memory Footprint Reporting<a class="headerlink" href="#memory-footprint-reporting" title="Link to this heading"></a></h3>
<p>With sparse variables (or particles), the memory footprint per
meshblock may vary with meshblock. Each <code class="docutils literal notranslate"><span class="pre">MeshBlock</span></code> object keeps a
running total of its memory footprint. You can get the footprint of an
individual meshblock by calling:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">MeshBlock::ReportMemUsage</span><span class="p">();</span>
</pre></div>
</div>
<p>If desired, you may also manually change the recorded memory footprint
of a given meshblock with the function:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">MeshBlock::LogMemUsage</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">delta</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">delta</span></code> is the change in memory.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Call <code class="docutils literal notranslate"><span class="pre">LogMemUsage</span></code> with caution! Variable and swarm allocation
and de-allocation are automatically tracked.</p>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="refinement_operations.html" class="btn btn-neutral float-left" title="Prolongation and Restriction Operations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="state.html" class="btn btn-neutral float-right" title="State Management" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, The Parthenon Collaboration and Triad National Security.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: brryan/mesh_swarm_bc_funcs
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Tags</dt>
      <dd><a href="../../../../regression-gold-v15/index.html">regression-gold-v15</a></dd>
      <dd><a href="../../../../regression-gold-v16/src/interface/sparse.html">regression-gold-v16</a></dd>
      <dd><a href="../../../../regression-gold-v17/src/interface/sparse.html">regression-gold-v17</a></dd>
      <dd><a href="../../../../regression-gold-v18/src/interface/sparse.html">regression-gold-v18</a></dd>
      <dd><a href="../../../../regression-gold-v19/src/interface/sparse.html">regression-gold-v19</a></dd>
      <dd><a href="../../../../regression-gold-v20/src/interface/sparse.html">regression-gold-v20</a></dd>
      <dd><a href="../../../../regression-gold-v21/src/interface/sparse.html">regression-gold-v21</a></dd>
      <dd><a href="../../../../regression-gold-v22/src/interface/sparse.html">regression-gold-v22</a></dd>
      <dd><a href="../../../../regression-gold-v23/src/interface/sparse.html">regression-gold-v23</a></dd>
      <dd><a href="../../../../regression-gold-v24/src/interface/sparse.html">regression-gold-v24</a></dd>
      <dd><a href="../../../../regression-gold-v25/src/interface/sparse.html">regression-gold-v25</a></dd>
      <dd><a href="../../../../v0.8.0/src/interface/sparse.html">v0.8.0</a></dd>
      <dd><a href="../../../../v23.11/src/interface/sparse.html">v23.11</a></dd>
      <dd><a href="../../../../v24.03/src/interface/sparse.html">v24.03</a></dd>
      <dd><a href="../../../../v24.08/src/interface/sparse.html">v24.08</a></dd>
    </dl>
    <dl>
      <dt>Branches</dt>
      <dd><a href="../../../../952-sparse_advection-format-string-incorrect/src/interface/sparse.html">952-sparse_advection-format-string-incorrect</a></dd>
      <dd><a href="../../../../BenWibking/move-params/src/interface/sparse.html">BenWibking/move-params</a></dd>
      <dd><a href="../../../../BenWibking/ubsan-clean-nan/src/interface/sparse.html">BenWibking/ubsan-clean-nan</a></dd>
      <dd><a href="../../../../BenWibking/update-cuda-ci-container/src/interface/sparse.html">BenWibking/update-cuda-ci-container</a></dd>
      <dd><a href="../../../../ats5/src/interface/sparse.html">ats5</a></dd>
      <dd><a href="../../../../ats5-cali/src/interface/sparse.html">ats5-cali</a></dd>
      <dd><a href="../../../../ats5-debug/src/interface/sparse.html">ats5-debug</a></dd>
      <dd><a href="../../../../bdw/gauss-quad/src/interface/sparse.html">bdw/gauss-quad</a></dd>
      <dd><a href="../../../../bprather/backport-bicgstab/src/interface/sparse.html">bprather/backport-bicgstab</a></dd>
      <dd><a href="../../../../bprather/backport-solvers/src/interface/sparse.html">bprather/backport-solvers</a></dd>
      <dd><a href="../../../../bprather/driver-overridable/src/interface/sparse.html">bprather/driver-overridable</a></dd>
      <dd><a href="../../../../bprather/fix-amr-ct/src/interface/sparse.html">bprather/fix-amr-ct</a></dd>
      <dd><a href="../../../../bprather/fix-line-continuation/src/interface/sparse.html">bprather/fix-line-continuation</a></dd>
      <dd><a href="../../../../bprather/fix-mpi-comms/src/interface/sparse.html">bprather/fix-mpi-comms</a></dd>
      <dd><a href="../../../../bprather/fix-mpi-comms-again/src/interface/sparse.html">bprather/fix-mpi-comms-again</a></dd>
      <dd><a href="../../../../bprather/fix-output-4GB-per-rank/src/interface/sparse.html">bprather/fix-output-4GB-per-rank</a></dd>
      <dd><a href="../../../../bprather/flat-set-bounds/src/interface/sparse.html">bprather/flat-set-bounds</a></dd>
      <dd><a href="../../../../bprather/mbd_add_niceties/src/interface/sparse.html">bprather/mbd_add_niceties</a></dd>
      <dd><a href="../../../../bprather/package-pack-dim/src/interface/sparse.html">bprather/package-pack-dim</a></dd>
      <dd><a href="../../../../bprather/par-reduce-inner/src/interface/sparse.html">bprather/par-reduce-inner</a></dd>
      <dd><a href="../../../../bprather/pep1/src/interface/sparse.html">bprather/pep1</a></dd>
      <dd><a href="../../../../bprather/print-less/src/interface/sparse.html">bprather/print-less</a></dd>
      <dd><a href="../../../../bprather/register-internal-op/src/interface/sparse.html">bprather/register-internal-op</a></dd>
      <dd><a href="../../../../bprather/reqs-for-ct/src/interface/sparse.html">bprather/reqs-for-ct</a></dd>
      <dd><a href="../../../../bprather/te-restart-fix/src/interface/sparse.html">bprather/te-restart-fix</a></dd>
      <dd><a href="../../../fix_neighbor_idx/src/interface/sparse.html">brryan/fix_neighbor_idx</a></dd>
      <dd><a href="../../../fix_particle_array/src/interface/sparse.html">brryan/fix_particle_array</a></dd>
      <dd><a href="../../../fix_swarm_mpi_reqs/src/interface/sparse.html">brryan/fix_swarm_mpi_reqs</a></dd>
      <dd><a href="../../../flux_refinement_ops/src/interface/sparse.html">brryan/flux_refinement_ops</a></dd>
      <dd><a href="../../../h5py_str_fix/src/interface/sparse.html">brryan/h5py_str_fix</a></dd>
      <dd><a href="../../../history++/src/interface/sparse.html">brryan/history++</a></dd>
      <dd><a href="../../../is_restart_soft_equiv/src/interface/sparse.html">brryan/is_restart_soft_equiv</a></dd>
      <dd><a href="sparse.html">brryan/mesh_swarm_bc_funcs</a></dd>
      <dd><a href="../../../more_swarm_prefix_sums/src/interface/sparse.html">brryan/more_swarm_prefix_sums</a></dd>
      <dd><a href="../../../no_swarm_dynamic_alloc/src/interface/sparse.html">brryan/no_swarm_dynamic_alloc</a></dd>
      <dd><a href="../../../pack_neighbors/src/interface/sparse.html">brryan/pack_neighbors</a></dd>
      <dd><a href="../../../param_whitespace_sanitize/src/interface/sparse.html">brryan/param_whitespace_sanitize</a></dd>
      <dd><a href="../../../particle_bcs_nordc/src/interface/sparse.html">brryan/particle_bcs_nordc</a></dd>
      <dd><a href="../../../particle_idx_bug/src/interface/sparse.html">brryan/particle_idx_bug</a></dd>
      <dd><a href="../../../particle_io_defrag/src/interface/sparse.html">brryan/particle_io_defrag</a></dd>
      <dd><a href="../../../swarm_comms_prefix/src/interface/sparse.html">brryan/swarm_comms_prefix</a></dd>
      <dd><a href="../../../swarm_mpi_tags/src/interface/sparse.html">brryan/swarm_mpi_tags</a></dd>
      <dd><a href="../../../swarm_new_bc_comms/src/interface/sparse.html">brryan/swarm_new_bc_comms</a></dd>
      <dd><a href="../../../swarm_tag_map_2/src/interface/sparse.html">brryan/swarm_tag_map_2</a></dd>
      <dd><a href="../../../swarms_smr/src/interface/sparse.html">brryan/swarms_smr</a></dd>
      <dd><a href="../../../userworkrestartoutput/src/interface/sparse.html">brryan/userworkrestartoutput</a></dd>
      <dd><a href="../../../../bumo-kokkos-42/src/interface/sparse.html">bumo-kokkos-42</a></dd>
      <dd><a href="../../../../dempsey/bnd_coords/src/interface/sparse.html">dempsey/bnd_coords</a></dd>
      <dd><a href="../../../../dempsey/dt/src/interface/sparse.html">dempsey/dt</a></dd>
      <dd><a href="../../../../dempsey/task_demangle/src/interface/sparse.html">dempsey/task_demangle</a></dd>
      <dd><a href="../../../../dempsey/timeout/src/interface/sparse.html">dempsey/timeout</a></dd>
      <dd><a href="../../../../develop/src/interface/sparse.html">develop</a></dd>
      <dd><a href="../../../../forrestglines/4D-outer-parallel-loop/src/interface/sparse.html">forrestglines/4D-outer-parallel-loop</a></dd>
      <dd><a href="../../../../forrestglines/cuda-with-nvc++-fix/src/interface/sparse.html">forrestglines/cuda-with-nvc++-fix</a></dd>
      <dd><a href="../../../../forrestglines/curvilinear/src/interface/sparse.html">forrestglines/curvilinear</a></dd>
      <dd><a href="../../../../forrestglines/fix-deprecated-kokkos-num-devices/src/interface/sparse.html">forrestglines/fix-deprecated-kokkos-num-devices</a></dd>
      <dd><a href="../../../../jdolence/curvilinear/src/interface/sparse.html">jdolence/curvilinear</a></dd>
      <dd><a href="../../../../jdolence/force_inline_inner/src/interface/sparse.html">jdolence/force_inline_inner</a></dd>
      <dd><a href="../../../../jdolence/instrument/src/interface/sparse.html">jdolence/instrument</a></dd>
      <dd><a href="../../../../jdolence/meshblockdata_add/src/interface/sparse.html">jdolence/meshblockdata_add</a></dd>
      <dd><a href="../../../../jdolence/move_string_creation/src/interface/sparse.html">jdolence/move_string_creation</a></dd>
      <dd><a href="../../../../jdolence/new_tasking/src/interface/sparse.html">jdolence/new_tasking</a></dd>
      <dd><a href="../../../../jdolence/quickfixes/src/interface/sparse.html">jdolence/quickfixes</a></dd>
      <dd><a href="../../../../jdolence/thread_safe/src/interface/sparse.html">jdolence/thread_safe</a></dd>
      <dd><a href="../../../../jdolence/timer_based_loadbalancing/src/interface/sparse.html">jdolence/timer_based_loadbalancing</a></dd>
      <dd><a href="../../../../jdolence/trace/src/interface/sparse.html">jdolence/trace</a></dd>
      <dd><a href="../../../../jmm/add-by-uid/src/interface/sparse.html">jmm/add-by-uid</a></dd>
      <dd><a href="../../../../jmm/custom-coords/src/interface/sparse.html">jmm/custom-coords</a></dd>
      <dd><a href="../../../../jmm/deprecate-unified-init/src/interface/sparse.html">jmm/deprecate-unified-init</a></dd>
      <dd><a href="../../../../jmm/dont-init-mpi-twice/src/interface/sparse.html">jmm/dont-init-mpi-twice</a></dd>
      <dd><a href="../../../../jmm/ensure-tags-work-on-device/src/interface/sparse.html">jmm/ensure-tags-work-on-device</a></dd>
      <dd><a href="../../../../jmm/fix-bool-vector-params/src/interface/sparse.html">jmm/fix-bool-vector-params</a></dd>
      <dd><a href="../../../../jmm/fix-noparticle-case/src/interface/sparse.html">jmm/fix-noparticle-case</a></dd>
      <dd><a href="../../../../jmm/fix-restart/src/interface/sparse.html">jmm/fix-restart</a></dd>
      <dd><a href="../../../../jmm/fix-split-io/src/interface/sparse.html">jmm/fix-split-io</a></dd>
      <dd><a href="../../../../jmm/fix-throw-fail/index.html">jmm/fix-throw-fail</a></dd>
      <dd><a href="../../../../jmm/flat-sparse/src/interface/sparse.html">jmm/flat-sparse</a></dd>
      <dd><a href="../../../../jmm/flatpack-test/src/interface/sparse.html">jmm/flatpack-test</a></dd>
      <dd><a href="../../../../jmm/get-me-off-this-rollercoaster/src/interface/sparse.html">jmm/get-me-off-this-rollercoaster</a></dd>
      <dd><a href="../../../../jmm/global-boundaries/src/interface/sparse.html">jmm/global-boundaries</a></dd>
      <dd><a href="../../../../jmm/global-boundaries-2/src/interface/sparse.html">jmm/global-boundaries-2</a></dd>
      <dd><a href="../../../../jmm/hotfix-sparse-control-fields/src/interface/sparse.html">jmm/hotfix-sparse-control-fields</a></dd>
      <dd><a href="../../../../jmm/include-guards/src/interface/sparse.html">jmm/include-guards</a></dd>
      <dd><a href="../../../../jmm/indexsplit/src/interface/sparse.html">jmm/indexsplit</a></dd>
      <dd><a href="../../../../jmm/make-get-parent-pointer-consistent/src/interface/sparse.html">jmm/make-get-parent-pointer-consistent</a></dd>
      <dd><a href="../../../../jmm/metadata-fix/src/interface/sparse.html">jmm/metadata-fix</a></dd>
      <dd><a href="../../../../jmm/metadataset/src/interface/sparse.html">jmm/metadataset</a></dd>
      <dd><a href="../../../../jmm/move-to-impl/src/interface/sparse.html">jmm/move-to-impl</a></dd>
      <dd><a href="../../../../jmm/move-userwork-before-loop-before-io/src/interface/sparse.html">jmm/move-userwork-before-loop-before-io</a></dd>
      <dd><a href="../../../../jmm/param-hash/src/interface/sparse.html">jmm/param-hash</a></dd>
      <dd><a href="../../../../jmm/particle-output/src/interface/sparse.html">jmm/particle-output</a></dd>
      <dd><a href="../../../../jmm/precomms-fill-derived/src/interface/sparse.html">jmm/precomms-fill-derived</a></dd>
      <dd><a href="../../../../jmm/remove-extraneous-check/src/interface/sparse.html">jmm/remove-extraneous-check</a></dd>
      <dd><a href="../../../../jmm/sparse-pack-exists/src/interface/sparse.html">jmm/sparse-pack-exists</a></dd>
      <dd><a href="../../../../jmm/sparsepack-wishlist/src/interface/sparse.html">jmm/sparsepack-wishlist</a></dd>
      <dd><a href="../../../../jmm/speed-up-compilation/src/interface/sparse.html">jmm/speed-up-compilation</a></dd>
      <dd><a href="../../../../jmm/threads-hack/src/interface/sparse.html">jmm/threads-hack</a></dd>
      <dd><a href="../../../../jmm/two-more-pedagogical-examples/src/interface/sparse.html">jmm/two-more-pedagogical-examples</a></dd>
      <dd><a href="../../../../jmm/use-system-packages/src/interface/sparse.html">jmm/use-system-packages</a></dd>
      <dd><a href="../../../../jmm/user-work-before-loop/src/interface/sparse.html">jmm/user-work-before-loop</a></dd>
      <dd><a href="../../../../jmm/yet-more-io-cleanup/src/interface/sparse.html">jmm/yet-more-io-cleanup</a></dd>
      <dd><a href="../../../../lfroberts36/speedup-buffer-kernel/src/interface/sparse.html">lfroberts36/speedup-buffer-kernel</a></dd>
      <dd><a href="../../../../lfroberts36/update-solver-convergence-criteria/src/interface/sparse.html">lfroberts36/update-solver-convergence-criteria</a></dd>
      <dd><a href="../../../../lroberts36/add-cg-solver/src/interface/sparse.html">lroberts36/add-cg-solver</a></dd>
      <dd><a href="../../../../lroberts36/add-combined-buffer-communication/src/interface/sparse.html">lroberts36/add-combined-buffer-communication</a></dd>
      <dd><a href="../../../../lroberts36/add-fine-field-deallocation/src/interface/sparse.html">lroberts36/add-fine-field-deallocation</a></dd>
      <dd><a href="../../../../lroberts36/add-fine-variables/src/interface/sparse.html">lroberts36/add-fine-variables</a></dd>
      <dd><a href="../../../../lroberts36/add-forest-block-orientation/src/interface/sparse.html">lroberts36/add-forest-block-orientation</a></dd>
      <dd><a href="../../../../lroberts36/add-forest-mesh-example/src/interface/sparse.html">lroberts36/add-forest-mesh-example</a></dd>
      <dd><a href="../../../../lroberts36/add-forest-of-octrees/src/interface/sparse.html">lroberts36/add-forest-of-octrees</a></dd>
      <dd><a href="../../../../lroberts36/add-forest-orientation-2/src/interface/sparse.html">lroberts36/add-forest-orientation-2</a></dd>
      <dd><a href="../../../../lroberts36/add-index-range-masking/src/interface/sparse.html">lroberts36/add-index-range-masking</a></dd>
      <dd><a href="../../../../lroberts36/add-more-careful-container-checking/src/interface/sparse.html">lroberts36/add-more-careful-container-checking</a></dd>
      <dd><a href="../../../../lroberts36/add-morton-numbers/src/interface/sparse.html">lroberts36/add-morton-numbers</a></dd>
      <dd><a href="../../../../lroberts36/add-multi-grid/src/interface/sparse.html">lroberts36/add-multi-grid</a></dd>
      <dd><a href="../../../../lroberts36/add-negative-levels/src/interface/sparse.html">lroberts36/add-negative-levels</a></dd>
      <dd><a href="../../../../lroberts36/add-non-one-copy-fluxes/src/interface/sparse.html">lroberts36/add-non-one-copy-fluxes</a></dd>
      <dd><a href="../../../../lroberts36/add-noncell-amr/src/interface/sparse.html">lroberts36/add-noncell-amr</a></dd>
      <dd><a href="../../../../lroberts36/add-small-riot/src/interface/sparse.html">lroberts36/add-small-riot</a></dd>
      <dd><a href="../../../../lroberts36/add-sparse-vector-wave-test/src/interface/sparse.html">lroberts36/add-sparse-vector-wave-test</a></dd>
      <dd><a href="../../../../lroberts36/add-task-graph/src/interface/sparse.html">lroberts36/add-task-graph</a></dd>
      <dd><a href="../../../../lroberts36/add-vector-wave-test/src/interface/sparse.html">lroberts36/add-vector-wave-test</a></dd>
      <dd><a href="../../../../lroberts36/boundary-comms-perforfmance-upgrades/src/interface/sparse.html">lroberts36/boundary-comms-perforfmance-upgrades</a></dd>
      <dd><a href="../../../../lroberts36/bugfix-sparse-cache/src/interface/sparse.html">lroberts36/bugfix-sparse-cache</a></dd>
      <dd><a href="../../../../lroberts36/bugfix-symmetrized-coordinates/src/interface/sparse.html">lroberts36/bugfix-symmetrized-coordinates</a></dd>
      <dd><a href="../../../../lroberts36/cleanup-offsets/src/interface/sparse.html">lroberts36/cleanup-offsets</a></dd>
      <dd><a href="../../../../lroberts36/composable-boundary-conditions/src/interface/sparse.html">lroberts36/composable-boundary-conditions</a></dd>
      <dd><a href="../../../../lroberts36/face-boundary-communication/src/interface/sparse.html">lroberts36/face-boundary-communication</a></dd>
      <dd><a href="../../../../lroberts36/fix-bitshift-of-negative/src/interface/sparse.html">lroberts36/fix-bitshift-of-negative</a></dd>
      <dd><a href="../../../../lroberts36/fix-dealloc-count-bug/src/interface/sparse.html">lroberts36/fix-dealloc-count-bug</a></dd>
      <dd><a href="../../../../lroberts36/fix-divide-by-zero/src/interface/sparse.html">lroberts36/fix-divide-by-zero</a></dd>
      <dd><a href="../../../../lroberts36/fix-forest-multigrid/src/interface/sparse.html">lroberts36/fix-forest-multigrid</a></dd>
      <dd><a href="../../../../lroberts36/fix-iterative-task-qualifiers/src/interface/sparse.html">lroberts36/fix-iterative-task-qualifiers</a></dd>
      <dd><a href="../../../../lroberts36/fix-multigrid-mpi/src/interface/sparse.html">lroberts36/fix-multigrid-mpi</a></dd>
      <dd><a href="../../../../lroberts36/fix-noncc-amr/src/interface/sparse.html">lroberts36/fix-noncc-amr</a></dd>
      <dd><a href="../../../../lroberts36/fix-one-block-minimum-per-rank/src/interface/sparse.html">lroberts36/fix-one-block-minimum-per-rank</a></dd>
      <dd><a href="../../../../lroberts36/fix-restart-state-bug/src/interface/sparse.html">lroberts36/fix-restart-state-bug</a></dd>
      <dd><a href="../../../../lroberts36/fix-root-level/src/interface/sparse.html">lroberts36/fix-root-level</a></dd>
      <dd><a href="../../../../lroberts36/fix-solver-relative-residual/src/interface/sparse.html">lroberts36/fix-solver-relative-residual</a></dd>
      <dd><a href="../../../../lroberts36/fix-sptr-cycle-tree/src/interface/sparse.html">lroberts36/fix-sptr-cycle-tree</a></dd>
      <dd><a href="../../../../lroberts36/fix-sptr-cycle-tree-2/src/interface/sparse.html">lroberts36/fix-sptr-cycle-tree-2</a></dd>
      <dd><a href="../../../../lroberts36/fix-static-refinement/src/interface/sparse.html">lroberts36/fix-static-refinement</a></dd>
      <dd><a href="../../../../lroberts36/generalize-par-dispatch/src/interface/sparse.html">lroberts36/generalize-par-dispatch</a></dd>
      <dd><a href="../../../../lroberts36/in-one-zero-memory-amr/src/interface/sparse.html">lroberts36/in-one-zero-memory-amr</a></dd>
      <dd><a href="../../../../lroberts36/local-face-fields/src/interface/sparse.html">lroberts36/local-face-fields</a></dd>
      <dd><a href="../../../../lroberts36/mg-riot-updates/src/interface/sparse.html">lroberts36/mg-riot-updates</a></dd>
      <dd><a href="../../../../lroberts36/multigrid-example-update/src/interface/sparse.html">lroberts36/multigrid-example-update</a></dd>
      <dd><a href="../../../../lroberts36/performance-updates/src/interface/sparse.html">lroberts36/performance-updates</a></dd>
      <dd><a href="../../../../lroberts36/refactor-mesh-constructors/src/interface/sparse.html">lroberts36/refactor-mesh-constructors</a></dd>
      <dd><a href="../../../../lroberts36/refactor-meshblockdata-initialization/src/interface/sparse.html">lroberts36/refactor-meshblockdata-initialization</a></dd>
      <dd><a href="../../../../lroberts36/refactor-partitioning/src/interface/sparse.html">lroberts36/refactor-partitioning</a></dd>
      <dd><a href="../../../../lroberts36/refactor-region-size/src/interface/sparse.html">lroberts36/refactor-region-size</a></dd>
      <dd><a href="../../../../lroberts36/refactor-solver-input/src/interface/sparse.html">lroberts36/refactor-solver-input</a></dd>
      <dd><a href="../../../../lroberts36/rename-cell-variable/src/interface/sparse.html">lroberts36/rename-cell-variable</a></dd>
      <dd><a href="../../../../lroberts36/reorganize/src/interface/sparse.html">lroberts36/reorganize</a></dd>
      <dd><a href="../../../../lroberts36/sparse-pack-update/src/interface/sparse.html">lroberts36/sparse-pack-update</a></dd>
      <dd><a href="../../../../lroberts36/speedup-buffer-kernel-split/src/interface/sparse.html">lroberts36/speedup-buffer-kernel-split</a></dd>
      <dd><a href="../../../../morarumaxim/neigh_collectives/src/interface/sparse.html">morarumaxim/neigh_collectives</a></dd>
      <dd><a href="../../../../neighborhood_ats5/src/interface/sparse.html">neighborhood_ats5</a></dd>
      <dd><a href="../../../../pgrete-patch-1/src/interface/sparse.html">pgrete-patch-1</a></dd>
      <dd><a href="../../../../pgrete-patch-bound_type/src/interface/sparse.html">pgrete-patch-bound_type</a></dd>
      <dd><a href="../../../../pgrete/adios2/src/interface/sparse.html">pgrete/adios2</a></dd>
      <dd><a href="../../../../pgrete/always-chunck/src/interface/sparse.html">pgrete/always-chunck</a></dd>
      <dd><a href="../../../../pgrete/ci-hamilton/src/interface/sparse.html">pgrete/ci-hamilton</a></dd>
      <dd><a href="../../../../pgrete/fix-ascent-vars/src/interface/sparse.html">pgrete/fix-ascent-vars</a></dd>
      <dd><a href="../../../../pgrete/fix-chunk/src/interface/sparse.html">pgrete/fix-chunk</a></dd>
      <dd><a href="../../../../pgrete/fix-hasghost-restart/src/interface/sparse.html">pgrete/fix-hasghost-restart</a></dd>
      <dd><a href="../../../../pgrete/histgram-analysis-pre-MG/src/interface/sparse.html">pgrete/histgram-analysis-pre-MG</a></dd>
      <dd><a href="../../../../pgrete/histgram-analysis-pre-MG-winput/src/interface/sparse.html">pgrete/histgram-analysis-pre-MG-winput</a></dd>
      <dd><a href="../../../../pgrete/histogram-outputs/src/interface/sparse.html">pgrete/histogram-outputs</a></dd>
      <dd><a href="../../../../pgrete/interpolation/src/interface/sparse.html">pgrete/interpolation</a></dd>
      <dd><a href="../../../../pgrete/non-atomic-scatter/src/interface/sparse.html">pgrete/non-atomic-scatter</a></dd>
      <dd><a href="../../../../pgrete/pgrete/pmd-output-wuser/src/interface/sparse.html">pgrete/pgrete/pmd-output-wuser</a></dd>
      <dd><a href="../../../../pgrete/pmd-output/src/interface/sparse.html">pgrete/pmd-output</a></dd>
      <dd><a href="../../../../pgrete/refactor-restart/src/interface/sparse.html">pgrete/refactor-restart</a></dd>
      <dd><a href="../../../../pgrete/sycl-test/src/interface/sparse.html">pgrete/sycl-test</a></dd>
      <dd><a href="../../../../pgrete/update-pool-alloc/src/interface/sparse.html">pgrete/update-pool-alloc</a></dd>
      <dd><a href="../../../../pgrete/user-output/src/interface/sparse.html">pgrete/user-output</a></dd>
      <dd><a href="../../../../pgrete/user-output-w-pmd/src/interface/sparse.html">pgrete/user-output-w-pmd</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>